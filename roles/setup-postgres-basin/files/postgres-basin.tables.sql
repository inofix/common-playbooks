-- # create tables

-- meta table to store internal info, like the schema version
CREATE TABLE IF NOT EXISTS _meta (
    schemaversion TEXT PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL,
    adminname TEXT,
    meta JSONB
);

-- persons to know, like users or project representatives
CREATE TABLE IF NOT EXISTS persons (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    version INTEGER NOT NULL -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_persons (
    id INTEGER NOT NULL REFERENCES persons(id),
    version INTEGER NOT NULL DEFAULT 0,
    name TEXT NOT NULL,
    uuid UUID,
    extid TEXT,
    extidtype VARCHAR(32),
    isnatural BOOLEAN,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

CREATE UNIQUE INDEX IF NOT EXISTS shadow_persons_uuid
ON shadow_persons (
    uuid, version
) WHERE uuid IS NOT NULL;

DO $$
BEGIN
    ALTER TABLE persons
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_persons(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- all sorts of contact data
CREATE TABLE IF NOT EXISTS contacts (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_contacts (
    id INTEGER REFERENCES contacts(id),
    version INTEGER NOT NULL DEFAULT 0,
    name TEXT NOT NULL,
    uuid UUID,
    icard text,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

CREATE UNIQUE INDEX IF NOT EXISTS shadow_contacts_uuid
ON shadow_contacts (uuid) WHERE uuid IS NOT NULL;

DO $$
BEGIN
    ALTER TABLE contacts
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_contacts(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- all data needs a project context
CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_projects (
    id INTEGER NOT NULL REFERENCES projects(id),
    version INTEGER NOT NULL DEFAULT 0,
    uuid UUID DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    representativepersonid INTEGER REFERENCES persons(id),
    publiccontactid INTEGER REFERENCES contacts(id),
    meta JSONB,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version),
    UNIQUE(uuid, version)
);

DO $$
BEGIN
    ALTER TABLE projects
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_projects(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- connecting people with contacts
CREATE TABLE IF NOT EXISTS personcontacts (
    personsubjectid INTEGER REFERENCES persons(id) NOT NULL,
    contactobjectid INTEGER REFERENCES contacts(id),
    projectcontextid INTEGER REFERENCES projects(id),
    isprimarycontact BOOLEAN DEFAULT False,
    PRIMARY KEY(personsubjectid, contactobjectid, projectcontextid)
);

-- the actual users on the system
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_users (
    id INTEGER NOT NULL REFERENCES users(id),
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    idtoken TEXT,
    idtokenhash VARCHAR(8),
    idtokentype VARCHAR(16),
    realpersonid INTEGER REFERENCES persons(id),
    version INTEGER NOT NULL DEFAULT 0,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

DO $$
BEGIN
    ALTER TABLE users
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_users(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- role based user permissions
CREATE TABLE IF NOT EXISTS roles (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_roles (
    id INTEGER NOT NULL REFERENCES roles(id),
    name TEXT NOT NULL,
    projectid INTEGER REFERENCES projects(id),
    isowner BOOLEAN DEFAULT False,
    canread BOOLEAN,
    canedit BOOLEAN,
    cancreate BOOLEAN,
    candelete BOOLEAN,
    cangrant BOOLEAN,
    version INTEGER NOT NULL DEFAULT 0,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

DO $$
BEGIN
    ALTER TABLE roles
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_roles(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- connecting users to roles
CREATE TABLE IF NOT EXISTS userroles (
    userid INTEGER REFERENCES users(id) NOT NULL,
    roleid INTEGER GENERATED ALWAYS AS IDENTITY NOT NULL,
    PRIMARY KEY(userid, roleid)
);

-- the type of data sources available
CREATE TABLE IF NOT EXISTS sourcetypes (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, -- db internal
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_sourcetypes (
    id INTEGER NOT NULL REFERENCES sourcetypes(id), -- db internal
    name TEXT, -- kind of source: location/site, vehicle, node, sensor, actuator api, etc.
    uuid UUID, -- e.g. comparable sensors
    class TEXT, -- only for devices, e.g. EdgeGateway
    devicetype TEXT, -- see above, e.g. RaspberryPi3
    realmname TEXT, -- Lifebase service
    realmuuid UUID, -- Lifebase service
    contentencoding VARCHAR(32),
    contenttype VARCHAR(32),
    contentrdfxtypes TEXT, -- RDF
    unit VARCHAR(16), --
    unitencoding VARCHAR(16),
    tolerance INTEGER,
    meta JSONB,
    version INTEGER NOT NULL DEFAULT 0,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

DO $$
BEGIN
    ALTER TABLE sourcetypes
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_sourcetypes(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- the data sources explaining all details of the recordings
--    uuid UUID DEFAULT public.uuid_generate_v4(),
CREATE TABLE IF NOT EXISTS sources (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, -- db internal
    version INTEGER -- see shadow
);

CREATE TABLE IF NOT EXISTS shadow_sources (
    id INTEGER NOT NULL REFERENCES sources(id), -- db internal
    uuid UUID DEFAULT gen_random_uuid(), -- global id
    extid TEXT, -- alternative for preexisting external reference if needed
    tree LTREE UNIQUE, -- hierarchical info
    name TEXT, -- short name, usually part of 'tree'..
    context TEXT, --
    sourcetypeid INTEGER REFERENCES sourcetypes(id) NOT NULL,
    projectid INTEGER REFERENCES projects(id) NOT NULL,
    parentid INTEGER REFERENCES sources(id),
    alt DOUBLE PRECISION,
    lat DOUBLE PRECISION,
    lon DOUBLE PRECISION,
    mapzoom INTEGER, -- for map displays, usually osm.org zoom
    geohash VARCHAR(12),
    timezone TEXT, -- e.g. 'Europe/Zurich'
    startdate TIMESTAMPTZ,
    stopdate TIMESTAMPTZ,
    samplerate INTEGER,
    meta JSONB,
    maintainerpersonid INTEGER REFERENCES persons(id),
    softwareversion TEXT,
    hardwareversion TEXT,
    version INTEGER NOT NULL DEFAULT 0,
    created TIMESTAMPTZ NULL,
    lastmodifieddate TIMESTAMPTZ NULL,
    lastmodifieduser INTEGER NULL,
    PRIMARY KEY(id, version)
);

DO $$
BEGIN
    ALTER TABLE sources
    ADD CONSTRAINT fk_current_version
    FOREIGN KEY (id, version)
    REFERENCES shadow_sources(id, version);
EXCEPTION
    WHEN duplicate_object THEN
        NULL; -- do not fail on subsequent run
END $$;

-- optional permission
CREATE TABLE IF NOT EXISTS personpermissions (
    roleid INTEGER REFERENCES roles(id) NOT NULL,
    projectid INTEGER REFERENCES projects(id) NOT NULL,
    personid INTEGER REFERENCES persons(id) NOT NULL,
    PRIMARY KEY(roleid, projectid, personid)
);

-- optional permission
CREATE TABLE IF NOT EXISTS contactpermissions (
    roleid INTEGER REFERENCES roles(id) NOT NULL,
    projectid INTEGER REFERENCES projects(id) NOT NULL,
    contactid INTEGER REFERENCES contacts(id) NOT NULL,
    PRIMARY KEY(roleid, projectid, contactid)
);

-- optional permission
CREATE TABLE IF NOT EXISTS sourcepermissions (
    roleid INTEGER REFERENCES roles(id) NOT NULL,
    projectid INTEGER REFERENCES projects(id) NOT NULL,
    sourceid INTEGER REFERENCES sources(id) NOT NULL,
    PRIMARY KEY(roleid, projectid, sourceid)
);

-- the actual data
--   projectid: double check that the project exists, we also create partitions here of
--   sourceid: inserts from sources will look up their and project ids on inserts
CREATE TABLE IF NOT EXISTS recordings (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    timestamp TIMESTAMPTZ NOT NULL,
    value DOUBLE PRECISION,
    altvalue JSONB,
    lat DOUBLE PRECISION,
    lon DOUBLE PRECISION,
    alt DOUBLE PRECISION,
    geohash VARCHAR(12),
    projectid INTEGER REFERENCES projects(id) NOT NULL,
    sourceid INTEGER REFERENCES sources(id) NOT NULL,
    meta JSONB,
    UNIQUE (timestamp, projectid, sourceid),
    PRIMARY KEY(id, timestamp, projectid)
) PARTITION BY LIST (projectid);

-- temporary storage for incoming data
CREATE TABLE IF NOT EXISTS recordings_staging (
    id INTEGER GENERATED ALWAYS AS IDENTITY,
    timestamp TIMESTAMPTZ NOT NULL,
    value DOUBLE PRECISION,
    altvalue JSONB,
    lat DOUBLE PRECISION,
    lon DOUBLE PRECISION,
    alt DOUBLE PRECISION,
    geohash VARCHAR(12),
    sourceuuid UUID NOT NULL,
    meta JSONB,
    PRIMARY KEY(id)
);

-- temporary storage for incoming data
CREATE TABLE IF NOT EXISTS _recordings_orphaned (
    id INTEGER GENERATED ALWAYS AS IDENTITY,
    timestamp TIMESTAMPTZ NOT NULL,
    value DOUBLE PRECISION,
    altvalue JSONB,
    lat DOUBLE PRECISION,
    lon DOUBLE PRECISION,
    alt DOUBLE PRECISION,
    geohash VARCHAR(12),
    sourceuuid UUID NOT NULL,
    meta JSONB,
    PRIMARY KEY(id)
);

